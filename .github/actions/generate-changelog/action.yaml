---
name: Changelog generate
description: Generating CHANGELOG.md
author: ixxeL
inputs:
  workingdir:
    description: directory in which to find the Dockerfile
    required: false
    default: .
  install:
    description: Prepare the job when not running in adequate environment
    required: false
    default: "true"
  prepare:
    description: Prepare the job when not running in adequate environment
    required: false
    default: "true"
  lower-tag:
    description: Name of the release
    required: false
    default: New release
  upper-tag:
    description: Name of the release
    required: false
    default: New release
  config-file:
    description: Name of the config changelog
    required: false
    default: ".config-changelog.yml"

runs:
  using: composite
  steps:
    - uses: actions/setup-python@v5
      if: ${{ inputs.install == 'true' }}
      with:
        python-version: "3.12"
    - id: prepare
      if: ${{ inputs.prepare == 'true' }}
      shell: bash
      run: |
        set +e
        if command -v pip &> /dev/null; then
          pip install pyyaml
        elif command -v pip3 &> /dev/null; then
          pip3 install pyyaml
        else
          echo "Error pip/pip3 not found"
          exit 1
        fi
      env:
        RED: \033[1;31m
        GREEN: \033[1;32m
        YELLOW: \033[1;33m
        BLUE: \033[1;34m
        PURPLE: \033[1;35m
        CYAN: \033[1;36m
        BLANK: \033[0m
    - id: generate-changelog
      working-directory: ${{ github.workspace }}
      run: |
        import subprocess
        import yaml
        import re
        from typing import List, Dict, Optional

        DEFAULT_CONFIG = {
            'groups': [
                {
                    'title': "üí• Breaking changes",
                    'regexp': r'^.*?(feat|chore|fix)!(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üöÄ New Features",
                    'regexp': r'^.*?feat(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üì¶ Dependency updates",
                    'regexp': r'^.*?chore(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "‚ö†Ô∏è Security updates",
                    'regexp': r'^.*?sec(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üêõ Bug fixes",
                    'regexp': r'^.*?(fix|refactor)(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üî® Refactoring",
                    'regexp': r'^.*?refactor(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "‚ôªÔ∏è Revert changes",
                    'regexp': r'^.*?revert(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üìö Documentation updates",
                    'regexp': r'^.*?docs(?:\(\w+\))?!?: .+$',
                },
                {
                    'title': "üèóÔ∏è Build process updates",
                    'regexp': r'^.*?(build|ci)(?:\(\w+\))?!?: .+$',
                }
            ]
        }

        def run_command(command: List[str]) -> str:
          result = subprocess.run(command, stdout=subprocess.PIPE, text=True)
          return result.stdout.strip()


        def run_command_list(command: List[str]) -> List[str]:
          result = subprocess.run(command, stdout=subprocess.PIPE, text=True)
          return result.stdout.strip().split('\n')


        def classify_commits(commits: List[str], groups: List[Dict[str, Optional[str]]]) -> Dict[str, List[str]]:
          classified_commits = {group['title']: [] for group in groups}
          classified_commits['üß∞ Other work'] = []

          for commit in commits:
              matched = False
              for group in groups:
                  regexp = group.get('regexp')
                  if regexp and commit and commit.strip() and re.match(regexp, commit):
                      classified_commits[group['title']].append(commit)
                      print(f"Commit identified as : {classified_commits[group['title']]}")
                      print(f"Group : {group}\n")
                      matched = True
                      break

              if not matched:
                  classified_commits['üß∞ Other work'].append(commit)

          return classified_commits

        def replace_pull_requests(message, repo_url):
          def replace(match):
              pull_number = match.group(1)
              return f'in ({repo_url}/pull/{pull_number})'

          return re.sub(r'\(#(\d+)\)$', replace, message)

        def generate_markdown(classified_commits, lower_tag, upper_tag, repo_url):
          markdown = "## Changelog\n"
          pattern = r'^([a-f0-9]+) (.+?) @(.+?)\s*(\(tag: (.+?)\))?$'

          for title, commits in classified_commits.items():
              if commits:
                  markdown += "### {}\n".format(title)
                  for commit in commits:
                      match = re.match(pattern, commit)
                      if match:
                        sha, rest, author, _, tags = match.groups()
                        rest = replace_pull_requests(rest, repo_url)
                        print(f"SHA: {sha}, REST: {rest}, AUTHOR: {author}, TAGS: {tags}")

                        # Modification pour g√©rer plusieurs tags
                        tag_list = tags.split(', ') if tags else []
                        tags_info = " {}".format(' '.join(
                            [f'[üè∑ {tag}]({repo_url}/tree/{tag.replace("tag: ", "")})' for tag in
                            tag_list])) if tag_list else ""

                        # Modification pour g√©n√©rer des liens sans " tag: "
                        tags_info = tags_info.replace(" tag: ", "")

                        markdown += "* {}: {} by (@{}){}\n".format(sha, rest, author, tags_info)
                      else:
                        print(f"Commit excluded: {commit}")
                  markdown += "\n"

          markdown += "**Full Changelog**: {}/compare/{}...{}".format(repo_url, lower_tag, upper_tag)
          return markdown

        def load_user_config(file_path):
          try:
              with open(file_path, 'r') as config_file:
                  return yaml.safe_load(config_file)
          except FileNotFoundError:
              return {}

        def merge_configs(default_config, user_config):
          merged_config = default_config.copy()
          merged_config.update(user_config)
          return merged_config

        def main():
          lower_tag = "${{ inputs.lower-tag }}"
          upper_tag = "${{ inputs.upper-tag }}"
          repo_url = "${{ github.server_url }}/${{ github.repository }}"

          config_file = "${{ inputs.config-file }}"

          commits = run_command_list(['git', 'log', f'{lower_tag}..{upper_tag}', '--pretty=format:%H %s @%an %d'])
          for commit in commits:
            print(commit)
          print("\n")

          user_config = load_user_config(config_file)
          config = merge_configs(DEFAULT_CONFIG, user_config)

          classified_commits = classify_commits(commits, config['groups'])

          final_markdown = generate_markdown(classified_commits, lower_tag, upper_tag, repo_url)

          print(final_markdown)

          with open('CHANGELOG.md', 'w') as file:
              file.write(final_markdown)

        if __name__ == "__main__":
            main()
      shell: python
      env:
        RED: \033[1;31m
        GREEN: \033[1;32m
        YELLOW: \033[1;33m
        BLUE: \033[1;34m
        PURPLE: \033[1;35m
        CYAN: \033[1;36m
        BLANK: \033[0m
